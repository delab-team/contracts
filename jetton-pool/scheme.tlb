bit$_ (## 1) = Bit;

bool_false$0 = Bool;
bool_true$1 = Bool;

bool_false$0 = BoolFalse;
bool_true$1 = BoolTrue;

nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;

left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;

addr_none$00 = MsgAddressNone;
addr_std$10 anycast:BoolFalse workchain_id:int8 address:bits256 = MsgAddressSimple;

_ _:MsgAddressNone = AddressStdOrNone;
_ _:MsgAddressSimple = AddressStdOrNone;

var_uint$_ {n:#} len:(#< n) value:(uint (len * 8)) = VarUInteger n;
nanograms$_ amount:(VarUInteger 16) = Coins;

// NOTE!!!
_ mint_params:(Maybe [forced_msg:^Cell mint_to:MsgAddressSimple])

// ------------------------------------------------------------------------------------------------
// ordinary Hashmap / HashmapE, with fixed length keys
// from https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n)
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X)
           right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;
// ------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------
// from TEP64 (https://github.com/ton-blockchain/TEPs/blob/master/text/0064-token-data-standard.md)
tail#_ {bn:#} b:(bits bn) = SnakeData ~0;
cons#_ {bn:#} {n:#} b:(bits bn) next:^(SnakeData ~n) = SnakeData ~(n + 1);
chunked_data#_ data:(HashmapE 32 ^(SnakeData ~0)) = ChunkedData;

snake#00 {n:#} data:(SnakeData ~n) = ContentData;
chunks#01 data:ChunkedData = ContentData;
// ------------------------------------------------------------------------------------------------

_ inited:Bool initializer:MsgAddressSimple salt:uint256 = PoolInitStorage;

_ token_a_root:MsgAddressSimple token_b_root:MsgAddressSimple token_l_root:MsgAddressSimple = PoolRoots;
_ token_a_wall:MsgAddressSimple token_b_wall:MsgAddressSimple token_l_wall:MsgAddressSimple = PoolWalls;
_ token_b_balance:Coins token_b_shared:Coins token_l_supply:Coins = PoolBalances;

_ inited:Bool initializer:MsgAddressSimple token_a_wall_set:Bool token_b_wall_set:Bool
    reward_amount:Coins last_reward_ts:uint32 reward_interval:uint32
    roots:^PoolRoots walls:^PoolWalls balances:^PoolBalances = PoolStorage;

constructor token_a_address:MsgAddressSimple token_b_address:MsgAddressSimple
    reward_amount:Coins reward_interval:uint32 lp_root_code:^Cell lp_wall_code:^Cell
    lp_name:^ContentData lp_symbol:^ContentData = PoolInternalMsgBody;
