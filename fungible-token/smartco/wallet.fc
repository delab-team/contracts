#pragma version ^0.3.0;

#include "libs/stdlib.fc";
#include "libs/delib.fc";

#include "utils/const.fc";
#include "utils/tl-b.fc";
#include "utils/context.fc";

#include "wallet/shared.fc";
#include "wallet/storage.fc";
#include "wallet/methods.fc";

int wallet::internal_transfer(slice msg_body) impure inline_ref {
    ctx::reserve(WALLET::TARGET_BALANCE);

    (
        int token_amount, slice from_address, slice response_address,
        int fwd_amount, cell fwd_body, int notifbounce
    ) = msg_body~load::wallet::internal_transfer_query();

    cell state_init = wallet::state_init(self::wallet_code, from_address, self::troot_addr);
    slice wallet_address = delib::addrstd_by_state(WALLET::WORKCHAIN, state_init);

    int root? = equal_slice_bits(msg::sender, self::troot_addr);
    int wall? = equal_slice_bits(msg::sender, wallet_address);
    throw_unless(ERR::ACCESS, root? | wall?);

    self::balance += token_amount;

    if (fwd_amount > 0) {
        cell body = build::general::transfer_notification_query(
            msg::query_id, token_amount, from_address, fwd_body
        );

        cell msg = delib::int_msg(self::owner_address, notifbounce, fwd_amount, body, delib::EC());
        send_raw_message(msg, MSGFLAG::SENDER_PAYS_FEES);
    }

    ;; NOTE: response_address mustn't be addr_none$00
    ctx::send_excesses(response_address, MSGFLAG::ALL_NOT_RESERVED);
    return true;
}

int wallet::burn(slice msg_body) impure inline_ref {
    ctx::only_owner(ERR::ACCESS, self::owner_address);
    throw_unless(ERR::BALANCE0, self::balance >= 0);
    throw_unless(ERR::NOT_ENOUGH, msg::value > msg::fwd_fee + 2 * STC::GAS_CONSUMPTION);

    (int token_amount, slice response_address) = msg_body~load::wallet::burn_query();
    delib::force_addr(response_address, WALLET::WORKCHAIN, false, ERR::ADDR_FORMAT);

    self::balance -= token_amount;

    cell body = build::root::burn_notification_query(
        msg::query_id, token_amount, msg::sender, response_address
    );

    cell msg = delib::int_msg(self::troot_addr, true, 0, body, delib::EC());
    send_raw_message(msg, MSGFLAG::REMAINING_GAS);

    return true;
}

int wallet::transfer(slice msg_body, int notifbounce) impure inline_ref {
    ctx::only_owner(ERR::ACCESS, self::owner_address);
    throw_unless(ERR::BALANCE0, self::balance >= 0);

    (
        int token_amount, slice to_address, slice response_address, int fwd_amount, cell fwd_body
    ) = msg_body~load::wallet::transfer_query();

    ;; if not fwd_amount: wal1->wal2, wal2->response (2 msgs)
    ;; if     fwd_amount: +wal2->owner(notif), +owner->wal2(bounced notif) (2 msgs)
    int fcount = fwd_amount ? 4 : 2;
    throw_if(ERR::NOT_ENOUGH,
        msg::value < fwd_amount
                    + WALLET::TARGET_BALANCE
                    + (fcount * msg::fwd_fee)
                    + (fcount * (STC::GAS_CONSUMPTION + STC::MIN_FOR_STORAGE))
    );

    delib::force_addr(to_address, WALLET::WORKCHAIN, false, ERR::ADDR_FORMAT);
    delib::force_addr(response_address, WALLET::WORKCHAIN, false, ERR::ADDR_FORMAT);

    self::balance -= token_amount;

    cell state_init = wallet::state_init(self::wallet_code, to_address, self::troot_addr);
    slice wallet_address = delib::addrstd_by_state(WALLET::WORKCHAIN, state_init);

    cell body = build::wallet::internal_transfer_query(
        msg::query_id, token_amount, self::owner_address,
        response_address, fwd_amount, fwd_body, notifbounce
    );

    cell msg = delib::int_msg(wallet_address, true, 0, body, state_init);
    send_raw_message(msg, MSGFLAG::REMAINING_GAS);
    return true;
}

;; bounced messages handler
int wallet::on_bounce(slice msg_body) impure inline_ref {
    throw_unless(
        ERR::INVOP_BOUNCE,
        (msg::op == op::wallet::internal_transfer_query) |
        (msg::op == op::root::burn_notification_query)   |
        (msg::op == op::general::transfer_notification_query)
    );

    _load_data();
    self::balance += msg_body~load_coins();
    ctx::send_excesses(self::owner_address, MSGFLAG::REMAINING_GAS);
    return true;
}

;; function selector by msg::op
int wallet::selector(slice msg_body) impure inline {
    if (msg::bounced?) { return (wallet::on_bounce(msg_body)); }

    _load_data();
    if (msg::op == op::wallet::internal_transfer_query) { return wallet::internal_transfer(msg_body); }
    if (msg::op == op::wallet::burn_query) { return wallet::burn(msg_body); }
    if (msg::op == op::wallet::transfer_query) { return wallet::transfer(msg_body, false); }
    if (msg::op == op::wallet::bouncable_transfer_query) { return wallet::transfer(msg_body, true); }

    return false;
}

;; internal message entry point
() recv_internal(int balance, int value, cell msg, slice msg_body) impure {
    throw_if(0, msg_body.slice_empty?()); ;; ignore empty messages

    msg_body~ctx::load(msg, balance, value);
    delib::force_addr(msg::sender, WALLET::WORKCHAIN, false, ERR::ADDR_FORMAT);

    if (wallet::selector(msg_body)) { return (_save_data()); }
    throw(0xffff); ;; not found
}
