#pragma version ^0.3.0;

global int      msg::op;
global int      msg::query_id;
global int      msg::bounced?;

global slice    msg::sender;
global int      msg::balance;
global int      msg::value;
global int      msg::fwd_fee;

(slice, ()) ctx::load(slice body, cell msg, int balance, int value) impure inline {
    slice cs = msg.begin_parse();

    int bounced? = cs~load_uint(4) & 1;
    slice sender = cs~load_msg_addr();

    cs~load_msg_addr(); ;; skip dst
    cs~load_coins();    ;; skip value
    cs~skip_bits(1);    ;; skip extracurrency collection
    cs~load_coins();    ;; skip ihr_fee

    if (bounced?) { body~skip_bits(32); }

    msg::op         = body~load_uint(32);
    msg::query_id   = body~load_uint(64);
    msg::bounced?   = bounced?;

    msg::sender     = sender;
    msg::balance    = balance;
    msg::value      = value;
    msg::fwd_fee    = cs~load_coins();

    return (body, ());
}

() ctx::send_excesses(slice to, int flag) impure inline {
    slice recv = to.slice_empty?() ? msg::sender : to;

    cell body = build::general::excesses_response(msg::query_id);
    send_raw_message(delib::int_msg(recv, false, 0, body, delib::EC()), flag);
}

() ctx::only_owner(int err, slice owner_address) impure inline {
    throw_unless(err, equal_slice_bits(msg::sender, owner_address));
}

() ctx::reserve(int target) impure inline {
    raw_reserve(max(msg::balance - msg::value, target), 0);
}
